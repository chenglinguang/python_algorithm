一.选择排序：
已知一组无序数据a[1]、a[2]、……a[n]，需将其按升序排列。首先比较a[1]与a[2]的值，若a[1]大于a[2]则交换两者的值，否则不变。再比较a[1]与a[3]的值，若a[1]大于a[3]则交换两者的值，否则不变。再比较a[1]与a[4]，依此类推，最后比较a[1]与a[n]的值。这样处理一轮后，a[1]的值一定是这组数据中最小的。再将a[2]与a[3]~a[n]以相同方法比较一轮，则a[2]的值一定是a[2]~a[n]中最小的。再将a[3]与a[4]~a[n]以相同方法比较一轮，依此类推。共处理n-1轮后a[1]、a[2]、……a[n]就以升序排列了。

二.插入排序：
将初始序列中的第一个元素作为一个有序序列，然后将剩下的 n-1 个元素按关键字大小依次插入该有序序列，每插入一个元素后依然保持该序列有序，经过 n-1 趟排序后使初始序列有序。

三.冒泡排序：
第一趟在序列(A[0]~A[n-1])中从前往后进行两个相邻元素的比较，若后者小，则交换，比较 n-1 次；第一趟排序结束，最大元素被交换到A[n-1]中，下一趟排序只需要在子序列(A[0]~A[n-2])中进行；冒泡排序最多进行 n-1 趟。基本的冒泡排序可以利用旗标的方式稍微减少一些比较的时间，当寻访完序列后都沒有发生任何的交换动作，表示排序已经完成，而无需再进行之后的比较与交换动作。

四.快速排序：
快速排序是找出一个元素（理论上可以随便找一个）作为基准(pivot),然后对数组进行分区操作,使基准左边元素的值都不大于基准值,基准右边的元素值 都不小于基准值，如此作为基准的元素调整到排序后的正确位置。递归快速排序，将其他n-1个元素也调整到排序后的正确位置。最后每个元素都是在排序后的正 确位置，排序完成。所以快速排序算法的核心算法是分区操作，即如何调整基准的位置以及调整返回基准的最终位置以便分治递归。
举例说明一下吧，这个可能不是太好理解。假设要排序的序列为

2 2 4 9 3 6 7 1 5 首先用2当作基准，使用i j两个指针分别从两边进行扫描，把比2小的元素和比2大的元素分开。首先比较2和5，5比2大，j左移

2 2 4 9 3 6 7 1 5 比较2和1，1小于2，所以把1放在2的位置

2 1 4 9 3 6 7 1 5 比较2和4，4大于2，因此将4移动到后面

2 1 4 9 3 6 7 4 5 比较2和7，2和6，2和3，2和9，全部大于2，满足条件，因此不变

经过第一轮的快速排序，元素变为下面的样子

[1] 2 [4 9 3 6 7 5]

之后，在把2左边的元素进行快排，由于只有一个元素，因此快排结束。右边进行快排，递归进行，最终生成最后的结果。


五.归并排序算法

原理,把原始数组分成若干子数组,对每一个子数组进行排序,

继续把子数组与子数组合并,合并后仍然有序,直到全部合并完,形成有序的数组

举例

无序数组[6 2 4 1 5 9]

先看一下每个步骤下的状态,完了再看合并细节

第一步 [6 2 4 1 5 9]原始状态

第二步 [2 6] [1 4] [5 9]两两合并排序,排序细节后边介绍

第三步 [1 2 4 6] [5 9]继续两组两组合并

第四步 [1 2 4 5 6 9]合并完毕,排序完毕

输出结果[1 2 4 5 6 9]

合并细节

详细介绍第二步到第三步的过程,其余类似

第二步:[2 6] [1 4] [5 9]

两两合并,其实仅合并[2 6] [1 4],所以[5 9]不管它,

原始状态

第一个数组[2 6]

第二个数组[1 4]

--------------------

第三个数组[...]

 

第1步,顺序从第一,第二个数组里取出一个数字:2和1

比较大小后将小的放入第三个数组,此时变成下边这样

第一个数组[2 6]

第二个数组[4]

--------------------

第三个数组[1]

 

第2步,继续刚才的步骤,顺序从第一,第二个数组里取数据,2和4,

同样的比较大小后将小的放入第三个数组,此时状态如下

第一个数组[6]

第二个数组[4]

--------------------

第三个数组[1 2]

 

第3步,再重复前边的步骤变成,将较小的4放入第三个数组后变成如下状态

第一个数组[6]

第二个数组[...]

--------------------

第三个数组[1 2 4]

 

第4步,最后将6放入,排序完毕

第一个数组[...]

第二个数组[...]

--------------------

第三个数组[1 2 4 6]

 

[ 1 2 4 6 ]与[ 5 9 ]的合并过程与上边一样,不再分解


